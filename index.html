<!DOCTYPE html>
<meta charset="utf-8">
<link rel="STYLESHEET" type="text/css" href="./style.css" />
<head> <title>playground 37</title> </head>
<body>

<div id="radbut">
  <input type="radio" name="mode" value="force-dynamic" id="rb-f-d" checked><label for="rb-f-d" >Force (dynamic)</label><br>
  <input type="radio" name="mode" value="force-static"  id="rb-f-s"        ><label for="rb-f-s" >Force (static)</label><br>
  <input type="radio" name="mode" value="scatter"       id="rb-scat"       ><label for="rb-scat">Scatter</label><br>
  <input type="radio" name="mode" value="geo"           id="rb-geo"        ><label for="rb-geo" >GeoMap</label>
</div>
<div class="container" id="mysvg"></div>

<script type="text/javascript" src="../include/js/d3/d3.v3.min.js"></script>
<script type="text/javascript" src="../include/js/d3/topo/topojson.v1.min.js"></script>
<script type="text/javascript">

  var margin = {"top": 40, "right": 40, "bottom": 40, "left": 40},
      width  = 800 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom,
      tmilli = 1000 // number of millis transitions take

  var myComms = []
  var myLeaders = []
  var nComms
  var data
  var force

  var svg = d3.select("#mysvg").append("svg")
          .attr("width",  width  + margin.left + margin.right)
          .attr("height", height + margin.top  + margin.bottom)
        .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

  var projection = d3.geo.equirectangular()
      .scale(153)
      .translate([width / 2, height / 2])
      .precision(.1)

  var path = d3.geo.path()
      .projection(projection)

  var graticule = d3.geo.graticule()

  svg.append("path")
      .datum(graticule)
      .attr("class", "graticule geo")
      .attr("d", path)
      .style("opacity", 0)    

  d3.json("../include/js/d3/topo/world-50m.json", function(error, world) {
    if (error) throw error

    svg.insert("path", ".graticule")
        .datum(topojson.feature(world, world.objects.land))
        .attr("class", "land geo")
        .attr("d", path)
        .style("opacity", 0)    

    svg.insert("path", ".graticule")
        .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b }))
        .attr("class", "boundary geo")
        .attr("d", path)
        .style("opacity", 0)    
  })

  
  var xValue = function(d) { return (d.pr)},
      xScale = d3.scale.linear().range([0, width]),
      xMap   = function(d) { return xScale(xValue(d))},
      xAxis  = d3.svg.axis().scale(xScale).orient("bottom")

  var yValue = function(d) { return (d.evcent)},
      yScale = d3.scale.linear().range([height, 0]),
      yMap   = function(d) { return yScale(yValue(d))},
      yAxis  = d3.svg.axis().scale(yScale).orient("left")

  var evcentmax=0, prmax=0

  function labelize(nodes, trans) {
    if (typeof nodes === "undefined") {
      d3.selectAll(".community_label")
        .transition()
        .duration(tmilli)
        .style("opacity", 0)
      return
    }
    function centroids(nodes, trans) {
      var m   = []
      myComms.forEach(function(o, i) {
        m[o + ".x"] = new Array()
        m[o + ".y"] = new Array()
      })
      nodes.forEach(function(o, i) {
        var thiscommunity = o.community + ""
        m[thiscommunity + ".x"].push(trans === "scatter" ? xMap(o.x) : o.x)
        m[thiscommunity + ".y"].push(trans === "scatter" ? yMap(o.y) : o.y)
      })
      var ret = []
      myComms.forEach(function(o, i) {
        ret[o + ".x"] = d3.mean(m[o + ".x"])
        ret[o + ".y"] = d3.mean(m[o + ".y"])
      })
      return ret
    }
    var roids = centroids(nodes)
    d3.selectAll(".label_back")
      .attr("x", function(){return roids[this.attributes.community.value + ".x"]-parseInt(this.attributes.width.value)/2})
      .attr("y", function(){return (roids[this.attributes.community.value + ".y"]-parseInt(this.attributes.height.value)+5+"px")})
    d3.selectAll(".label_text")
      .attr("x", function(){return roids[this.attributes.community.value + ".x"]})
      .attr("y", function(){return roids[this.attributes.community.value + ".y"]})
    return
  }

  function toscatter() {
    //console.log("toscatter: ")
    d3.selectAll(".scatter")
      .transition()
      .duration(tmilli)
      .style("opacity", 1)
    force.stop()
    d3.selectAll(".node")
      .transition()
      .duration(tmilli)
      .attr("cx", function(d){return xMap(d)})
      .attr("cy", function(d){return yMap(d)})
      .attr("fixed", true)
      .style("opacity", 1)
    d3.selectAll(".link")
      .transition()
      .duration(tmilli)
      .attr("x1", function(d){
        return(xMap(d.source))
      })
      .attr("y1", function(d){return(yMap(d.source))})
      .attr("x2", function(d){return(xMap(d.target))})
      .attr("y2", function(d){return(yMap(d.target))})
      .style("stroke-opacity", 0.125)
    labelize()
  }

  function toforce() {
    d3.selectAll(".link")
      .transition()
      .duration(tmilli)
      .attr("x1", function(d){return(d.source.x)})
      .attr("y1", function(d){return(d.source.y)})
      .attr("x2", function(d){return(d.target.x)})
      .attr("y2", function(d){return(d.target.y)})
      .style("stroke-opacity", 0.25)
    d3.selectAll(".node")
      .transition()
      .duration(tmilli)
      .attr("cx", function(d){return(d.x_old||0)})
      .attr("cy", function(d){return(d.y_old||0)})
      .style("opacity", 1)
    labelize(data.nodes, "force")
    d3.selectAll(".label_text")
      .transition()
      .duration(tmilli)
      .style("opacity", 1)
    d3.selectAll(".label_back")
      .transition()
      .duration(tmilli)
      .style("opacity", 0.75)
  }

  function fromgeo() {
    d3.selectAll(".geo")
      .transition()
      .duration(tmilli)
      .style("opacity", 0)
  }

  function fromscatter() {
    d3.selectAll(".scatter")
      .transition()
      .duration(tmilli)
      .style("opacity", 0)
  }

  function togeo() {
    d3.selectAll(".geo")
      .transition()
      .duration(tmilli)
      .style("opacity", 1)
    d3.selectAll(".node")
      .transition()
      .duration(tmilli)
      .attr("cx", function(d){cx=projection([d.location.lon, d.location.lat])[0]; return cx})
      .attr("cy", function(d){cy=projection([d.location.lon, d.location.lat])[1]; return cy})
      .attr("fixed", true)
      .style("opacity", 0.25)
    d3.selectAll(".link")
      .transition()
      .duration(tmilli)
      .attr("x1", function(d){x1=projection([d.source.location.lon, d.source.location.lat])[0]; return x1})
      .attr("y1", function(d){y1=projection([d.source.location.lon, d.source.location.lat])[1]; return y1})
      .attr("x2", function(d){x2=projection([d.target.location.lon, d.target.location.lat])[0]; return x2})
      .attr("y2", function(d){y2=projection([d.target.location.lon, d.target.location.lat])[1]; return y2})
      .style("stroke-opacity", 0.25)
    labelize()
  }

  // https://github.com/mbostock/d3/blob/gh-pages/talk/20111018/collision.html#L76-101
  // i really dislike this code. i hope nobody ever looks here. but it works. and that's hard to argue with.
  function collide(node) {
  //    var r1  = 2 + (radtype ? node.pr_rad : node.evc_rad)
    var r1  = 1 + node.radius
    var nx1 = node.x - r1
    var nx2 = node.x + r1
    var ny1 = node.y - r1
    var ny2 = node.y + r1
    return function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== node)) {
        var x = node.x - quad.point.x
        var y = node.y - quad.point.y
        var l = Math.sqrt(x * x + y * y)
//        var r = radtype ? (node.pr_rad + quad.point.pr_rad) : (node.evc_rad + quad.point.evc_rad)
        var r = node.radius + quad.point.radius
        if (l < r) {
          l = (l - r) / l * 0.5
          node.x -= x *= l
          node.y -= y *= l
          quad.point.x += x
          quad.point.y += y
        }
      }
      return x1 > nx2
          || x2 < nx1
          || y1 > ny2
          || y2 < ny1
    }
  }

  function mymin(dec) {  // i do realize this would be the time to demonstrate my knowledge of recursion and unreadable code.
    if (dec < 1) { return 0 }
    var ret = 1/2
    while (dec>0) {
      ret /= 10
      dec--
    }
    return ret
  }

  // http://java-scripts.net/javascripts/Format-Number.phtml
  function fmt(pnumber, decimals){
    if (isNaN(parseFloat(pnumber)))  { return ''}
    if (pnumber==0)                  { return 0}
    if (pnumber=='')                 { return ''}
    if (!isFinite(pnumber))          { return ''}
    if (pnumber < mymin(decimals)/2) { return '0.0'}
    var snum = new String(pnumber)
    var sec = snum.split('.')
    var whole = parseFloat(sec[0])
    var result = ''
    if (sec.length > 1) {
      var dec = new String(sec[1])
      dec = String(parseFloat(sec[1])/Math.pow(10,(dec.length - decimals)))
      dec = String(whole + Math.round(parseFloat(dec))/Math.pow(10,decimals))
      var dot = dec.indexOf('.')
      if(dot == -1){
        dec += '.'
        dot = dec.indexOf('.')
      }
      while (dec.length <= dot + decimals) { dec += '0' }
      result = dec
    } else {
      var dot
      var dec = new String(whole)
      dec += '.'
      dot = dec.indexOf('.')
      while (dec.length <= dot + decimals) { dec += '0' }
      result = dec
    }
    return result
  }

  function nComms(nodes) {
    nodes.forEach(function(o, i) {
      var community = o.community + "" // make sure community is a string
      myComms.push(community)
      if (o.prlead) { myLeaders[community] = i }
    })
    myComms = d3.set(myComms).values().sort()
    return myComms.length
  }

  // https://www.randomlists.com/random-words
  var topics = [
      "wealth unit",
      "airplanes",
      "substantial increment",
      "next dimension",
      "utopian cause",
      "savory",
      "aggressive investment",
      "harmonious interests",
      "arrive prepared",
      "appear helpless",
      "undamaged cooperative",
      "watch group"
  ]

  d3.json("./data2.json", function(error, json) {
    if (error) return console.warn(error)
    data = json
    var r = (width+height)/3,
        x = width/2,
        y = height/2
    nComms = nComms(data.nodes)
    data.nodes.forEach(function(d, i) {
      var wiggle = i/data.nodes.length
      d.x = x + wiggle * r * Math.cos((2*Math.PI*(d.community + wiggle))/nComms)
      d.y = y + wiggle * r * Math.sin((2*Math.PI*(d.community + wiggle))/nComms)
      prmax = (prmax<d.pr) ? d.pr : prmax
      evcentmax = (evcentmax<d.evcent) ? d.evcent : evcentmax
    })

    var padding = 20
    var xmin = d3.min(data.nodes, xValue)
    var xmax = d3.max(data.nodes, xValue)
    var ymin = d3.min(data.nodes, yValue)
    var ymax = d3.max(data.nodes, yValue)

    xScale.domain([xmin, xmax])
    yScale.domain([ymin, ymax])

    var yAxis = d3.svg.axis()
      .orient("left")
      .scale(yScale)

    var xAxis = d3.svg.axis()
      .orient("bottom")
      .scale(xScale)

    svg.append("g")
      .attr("class", "yaxis axis scatter")
      .style("opacity", 0)
      .call(yAxis)
  
    svg.append("text")
      .attr("class", "ylabel label axis scatter")
      .attr("transform", "translate(" + padding + "," + 0 + ")rotate(-90)") 
      .style("opacity", 0)
      .text("Eigenvector Centrality")

    svg.append("g")
      .attr("class", "xaxis axis scatter")   // give it a class so it can be used to select only xaxis labels  below
      .attr("transform", "translate(0," + height + ")")
      .style("opacity", 0)
      .call(xAxis)

    svg.append("text")
      .attr("class", "xlabel label axis scatter")
      .attr("transform", "translate("+ width + "," + (height - 5) + ")") 
      .style("opacity", 0)
      .text("PageRank")

    force = d3.layout.force()
      .gravity(0.15)
      .charge(      function(d) { return (-d.radius*5) })
      .linkDistance(function(d) { return (
          Math.max(d.source.radius, d.target.radius)*1.5
        + Math.max(d.source.radius, d.target.radius)*2
      )})
      .linkStrength(0.005)
      .size([width, height])
      .nodes(data.nodes)
      .links(data.links)
      .start() // start out with a dynamic force-directed graph

    var link = svg.selectAll(".link")
      .data(data.links)
      .enter().append("line")
      .attr("class", "link")
      .style("stroke",         function(d){return d3.rgb(d.source.color) })
      .style("stroke-width",   function(d){return d.width })
      .style("stroke-opacity", 0.25)

    var node = svg.selectAll(".node")
      .data(data.nodes)
      .enter().append("circle")
      .attr("class", function(d){return "node" + (d.prlead ? " lead" : (d.isperson==1 ? "" : " maillist")) })
      .attr("r",     function(d){return d.radius })
      .style("fill", function(d){return d.prlead ? d3.rgb(d.color).darker(2) : d3.rgb(d.color) })
      .style("stroke-width", function(d){return Math.max(d.radius/10,1)})
      .call(force.drag)

    var commlab = svg.selectAll(".comms")
      .data(data.nodes).enter()
      data.nodes.forEach(function(o, i) {
        //console.log("i: " + i)
        if (o.prlead) {
          svg.append("rect")
            .attr("class", "community_label label_back")
            .attr("height", "20px")
            .attr("width", (10 + topics[o.community].length * 7.5) + "px")
            .attr("rx", 10)
            .attr("ry", 10)
            .attr("community", o.community)
            .attr("node", i)
            .style("fill", "grey")
            .style("opacity", 0.75)
          svg.append("text")
            .attr("class", "community_label label_text")
            .attr("text-anchor", "middle")
            .style("fill", "white")
            .text(topics[o.community])
            .attr("community", o.community)
            .attr("node", i)
        }
    })
      
    force.on("tick", function (e) {
      var q = d3.geom.quadtree(data.nodes)
      var k = e.alpha/20
      data.nodes.forEach(function(node) {
        var leader = myLeaders[node.community + ""]
        if (node !== leader) {
          node.y += k * (data.nodes[leader].y-node.y)
          node.x += k * (data.nodes[leader].x-node.x)
        }
        q.visit(collide(node))
      })

      link
        .attr("x1", function(d){ return d.source.x })
        .attr("y1", function(d){ return d.source.y })
        .attr("x2", function(d){ return d.target.x })
        .attr("y2", function(d){ return d.target.y })

      node
        .attr("cx", function(d){ return d.x })
        .attr("cy", function(d){ return d.y })

      labelize(data.nodes, "force")
    })
   
    var lastbutton = ""
 
    d3.selectAll("#radbut input[name=mode]").on("change", function() {
      var d = new Date()
      var button = this.value
      // get the current position of each node
      // should do this for each link too
      d3.selectAll(".node")
        .attr("__dummy__", function(d) {d.x_old = d.x; d.y_old = d.y; return})
      if (lastbutton == "geo")     fromgeo()
      if (lastbutton == "scatter") fromscatter()
      button === "force-dynamic" ? force.start() : force.stop()
      switch (button) { 
        case "force-dynamic":
          toforce(true)
          break
        case "force-static":
          toforce(false)
          break
        case "scatter":
          toscatter()
          break
        case "geo":
          togeo()
          break
        default:
          toforce(true)
          break
      }
      lastbutton = button
    })

  })

</script>

</body>
</html>
